#############
# functions #
#############

die(){
        TYPE="ERROR"
        if [ "$#" -gt 1 ] ; then
                TYPE="$1"
                shift
        fi
        printf "${TYPE}: " >&2
        while [ "$1" ] ; do
                echo "$1" >&2
                shift
        done
        echo "" >&2

        exit 1
}

get_interface_list(){
	LANG=C ip a |sed -ne "/^[[:digit:]]\+:/{s%^[[:digit:]]\+:[[:blank:]]\+%%;s%:.*$%%;p}"
}

get_gw_iface(){
	# prints default route iface name
	LANG=C ip -4 route list 0/0 | cut -d ' ' -f 5
}

create_virt_iface(){
	# create virtual interface over physical interface
	# currently supports only macvtap mode bridge
	# parameters:
	VIRTUAL_IFACE="$1"	# -> VIRT_IFACE_NAME
	PHYSICAL_IFACE="$2"	# -> PHYS_IFACE

	ip link add "$VIRTUAL_IFACE" link "$PHYSICAL_IFACE" type macvlan mode bridge
}

get_domain(){
	# get search domain from resolv.conf
	# remove "dot" at beginning of string 
	# this also discards a simple dot as search domain (as some providers do!)
	sed -ne "/^[[:blank:]]*search/{s%^.*[[:blank:]]%%;s%^\.%%;p}" /etc/resolv.conf
}

get_iface_cidr(){
	# prints IP/NETMASK from specified interface
	# parameters:
	IFACE_NAME="$1"

	LANG=C ip addr show "$IFACE_NAME" |sed -ne "/[[:blank:]]*inet[[:blank:]]/{s%^.*inet[[:blank:]]%%;s%[[:blank:]].*$%%;p}"
}

bin2byte(){
	# convert binary byte to decimal format
	# parameters:
	BBYTE="$1"
	printf "$(echo "obase=10;ibase=2;$BBYTE" |bc)"
}

byte2bin(){
	# convert decimal byte to binary and pad with 8 0's
	# parameters:
	DBYTE="$1"
	printf "%08d" "$(echo "obase=2;$DBYTE" |bc)"
}

get_firstbits(){
	# extract first n bits from a 32 bits binary number
	# parameters:
	BNUM="$1"	# -> 32 bits binary number
	n=$2		# -> number of bits

	N=$((32 - $n))
	echo "$BNUM" |sed -e "s%[[:digit:]]\{$N\}$%%"
}

get_lastbits(){
	# extract last n bits from a 32 bits binary number
	# parameters:
	BNUM="$1"	# -> 32 bits binary number
	n=$2		# -> number of bits

	N=$((32 - $n))
	echo "$BNUM" |sed -e "s%^[[:digit:]]\{$N\}%%"
}

get_byte(){
	# get nth byte of a 32 bits binary number (from left to right, 1 is the first byte)
	# parameters:
	BNUM="$1"	# -> 32 bits binary number
	n=$2		# -> byte number
	if [ $n -gt 1 ] ; then
		# remove first (n-1)*8 bits
		N=$(( ($n-1)*8))
		BNUM="$(echo "$BNUM" |sed -e "s%^[[:digit:]]\{$N\}%%")"
	fi
	if [ $n -lt 4 ] ; then
		# remove last (4-n)*8 bits
		N=$(( (4-$n)*8 ))
		BNUM="$(echo "$BNUM" |sed -e "s%[[:digit:]]\{$N\}$%%")"
	fi
	echo "$BNUM"
}

ip2bin(){
	# convert decimal dot separated IP address to 32 bits binary format
	# parameters:
	DOT_IP="$1"
	for b in $(echo "$DOT_IP" |tr "." " ") ; do
		byte2bin "$b"
	done
}

bin2ip(){
	# convert 32 bits binary IP to decimal dot separated form
	# parameters:
	BIN_IP="$1"
	DOT_IP=""
	n=1
	while [ $n -le 4 ] ; do
		BIN_BYTE="$(get_byte "$BIN_IP" $n)"
		DOT_IP="${DOT_IP}.$(bin2byte "$BIN_BYTE")"
		n=$(($n + 1))
	done
	printf "${DOT_IP#.}"
}


get_srv_cidr(){
	# receives a CIDR ip/mask parameter of any host in subnet
	# and returns the nth ip in the related subnet
	# parameters:
	CIDR="$1" 	# IP/MASK
	IP_NUMBER="$2"  # -> subnet IP position
	
	# separate IP / MASK & calculate HOST_NUMBITS
	IP="${CIDR%/*}"
	MASK="${CIDR#*/}"
	HOST_NUMBITS=$((32 - $MASK))

	# verify subnet max number of hosts
	MAX_HOST="$(echo "2^${HOST_NUMBITS} - 1" |bc)"
	[ $IP_NUMBER -le $MAX_HOST ] || die "Insufficient number of hosts in subnet"

	# convert IP to binary
	BIN_IP="$(ip2bin "$IP")"

	# preserve subnet part in binary form
	BIN_NET="$(get_firstbits "$BIN_IP" $MASK)"

	# convert host number to binary and pad with required 0's 
	BIN_HOST_RAW="$(echo "obase=2;$IP_NUMBER" |bc)"
	BIN_HOST="$(printf "%0${HOST_NUMBITS}d" "$BIN_HOST_RAW")"

	# concatenate to get binary server IP and convert to dot separated format
	BIN_SRV_IP="${BIN_NET}${BIN_HOST}"
	printf "$(bin2ip "$BIN_SRV_IP")/$MASK"
}

get_srv_ip(){
	# this function is a wrapper of get_srv_cidr to parse only IP address
	# 
	# parameters:
	CIDR="$1" 	# IP/MASK
	IP_NUMBER="$2"  # -> subnet IP position
	get_srv_cidr "$CIDR" "$IP_NUMBER" |sed -e "s%/.*$%%"
}

print_host(){
	# prints single line in etc/hosts format for an IP and hostname
	# parameters:
	IP="$1"
	HOST="$2"
	printf "${IP}\t${H}\n"
}

generate_hosts(){
	# prints list of pairs "IP hostname" in etc/hosts format
	# the function can receive many parameters in the form:
	# IP:alias_list_comma_separated[:optional_domain_name_list]
	while [ "$1" ] ; do
		# extract parameters
		DOMAIN_LIST=""
		IP="${1%%:*}"
		ALIAS_LIST="${1#*:}"
		if echo "$ALIAS" | grep -q ":" ; then
			DOMAIN_LIST="${ALIAS_LIST#*:}"
			ALIAS_LIST="${ALIAS_LIST%:*}"
		fi
		for H in $(echo "$ALIAS_LIST" | tr "," " ") ; do
			print_host "$IP" "$H"
			for D in $(echo "$DOMAIN_LIST" | tr "," " ") ; do
				print_host "$IP" "${H}.${D}"
			done
		done
		shift
	done
}

